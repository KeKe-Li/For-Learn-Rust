### rust 学习

Rust 之所以受欢迎是因为其内存安全性。在以往，内存安全几乎都是通过 GC 的方式实现，但是 GC 会引来性能、内存占用以及 `Stop the world `等问题，在高性能场景和系统编程上是不可接受的，因此 Rust 采用了所有权系统。

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。

在计算机语言不断演变过程中，出现了三种流派：

* 垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，代表语言：Java、Go
* 手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
* 通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查

其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

#### 复合类型

#### 枚举

枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员。

* 枚举值

通过 `::` 操作符来访问 枚举中的具体成员，接着可以定义一个函数来使用它们：
```rust
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}

let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
```

* Option 枚举用于处理空值

在其它编程语言中，往往都有一个 null 关键字，该关键字用于表明一个变量当前的值为空（不是零值，例如整型的零值是 0），也就是不存在值。当你对这些 null 进行操作时，例如调用一个方法，就会直接抛出null 异常，导致程序的崩溃，因此我们在编程时需要格外的小心去处理这些 null 空值。

Rust 吸取了众多教训，决定抛弃 null，而改为使用 Option 枚举变量来表述这种结果。

其实在js中null和 undefined 比较常见，undefined 代表变量的值未定义，null 代表变量的值默认为空值。

Option 枚举包含两个成员，一个成员表示含有值：Some(T), 另一个表示没有值：None，定义如下：

```rust
enum Option<T> {
    Some(T),
    None,
}
```
其中 T 是泛型参数，`Some(T)`表示该枚举成员的数据类型是 T，换句话说，Some 可以包含任何类型的数据。

`Option<T> `枚举是如此有用以至于它被包含在了 prelude（prelude 属于 Rust 标准库，Rust 会将最常用的类型、函数等提前引入其中，省得我们再手动引入）之中，你不需要将其显式引入作用域。另外，它的成员 Some 和 None 也是如此，无需使用 `Option::` 前缀就可直接使用 Some 和 None。

```rust
let some_number = Some(10);
let some_string = Some("keke");

let absent_number: Option<i32> = None;
```

如果使用 None 而不是 Some，需要告诉 `Rust Option<T>` 是什么类型的，因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型。

当有一个 Some 值时，我们就知道存在一个值，而这个值保存在 Some 中。当有个 None 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。


#### 数组

在 Rust 中，最常用的数组有两种：

* 第一种是速度很快但是长度固定的 array。
* 第二种是可动态增长的但是有性能损耗的 Vector。

在这里，我们称 array 为数组，Vector 为动态数组。 这两个数组的关系跟 `&str` 与 `String` 的关系很像，前者是长度固定的字符串切片，后者是可动态增长的字符串。

其实，在 Rust 中无论是 String 还是 Vector，它们都是 Rust 的高级类型：集合类型.

数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。出数组的三要素：

* 长度固定.
* 元素必须有相同的类型.
* 依次线性排列.

注意，这里说的数组是 Rust 的基本类型，是固定长度的，这点与其他编程语言不同，其它编程语言的数组往往是可变长度的，与 Rust 中的动态数组 Vector 类似。


#### 创建数组

在 Rust 中，数组是这样定义的：
```rust
fn main() {
    let a = [1, 2, 3, 4, 5, 6, 7, 8];
}
```

由于它的元素类型大小固定，且长度也是固定，因此数组 array 是存储在栈上，性能也会非常优秀。

与此对应，动态数组 Vector 是存储在堆上，因此长度可以动态改变。当你不确定是使用数组还是动态数组时，那就应该使用后者.

通常情况下我们可以看到，数组声明类型:
```rust
let a: [i32; 8] = [1, 2, 3, 4, 5, 6, 7, 8];
```

这里，数组类型是通过方括号语法声明，i32 是元素类型，分号后面的数字 8 是数组长度，数组类型也从侧面说明了数组的元素类型要统一，长度要固定。

还可以使用下面的语法初始化一个某个值重复出现 N 次的数组：

```rust
let a = [3; 6];
```
a 数组包含 6 个元素，这些元素的初始化值为 3，这种语法跟数组类型的声明语法其实是保持一致的：`[3; 6]` 和 `[类型; 长度]`。

在元素重复的场景，这种写法要简单的多，`let a = [3, 3, 3, 3, 3, 3];` 。


* 访问数组元素

因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：

```rust
fn main() {
    let a = [10, 9, 7, 6, 5];

    let first = a[0]; // 获取a数组第一个元素
    let second = a[1]; // 获取第二个元素
}
```
数组的索引下标是从 0 开始的。此处，first 获取到的值是 10，second 是 9。

* 越界访问

如果使用超出数组范围的索引访问数组元素，那么就会直接报错。

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();
    // 读取控制台的输出
    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!(
        "The value of the element at index {} is: {}",
        index, element
    );
}
```

使用 `cargo run` 来运行代码，因为数组只有 5 个元素，如果我们试图输入 5 去访问第 6 个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：
```bash
Please enter an array index.
5
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

这就是数组访问越界，访问了数组中不存在的元素，导致 Rust 运行时错误。程序因此退出并显示错误消息，未执行最后的 println! 语句。

当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust 会出现 panic。这种检查只能在运行时进行，比如在上面这种情况下，编译器无法在编译期知道用户运行代码时将输入什么值。

* 数组元素为非基础类型

String的多个组成的数组只能这样实现：

```rust
let array: [String; 8] = core::array::from_fn(|i| String::from("rust is good!"));

println!("{:#?}", array);
```

因为基本类型在Rust中赋值是以Copy的形式，`let array=[3;6]`底层就是不断的Copy出来的，但很可惜复杂类型都没有深拷贝，只能一个个创建。

这里的String是通过调用 `std::array::from_fn`.

#### 数组切片

切片 这个概念，它允许你引用集合中的部分连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &[i32] = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

数组切片 slice 的类型是`&[i32]`，与之对比，数组的类型是`[i32;5]`，总结下切片的特点：

* 切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置。
* 创建切片的代价非常小，因为切片只是针对底层数组的一个引用。
* 切片类型`[T]`拥有不固定的大小，而切片引用类型`&[T]`则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此`&[T]`更有用,`&str`字符串切片也同理。

数组和切片区别:

* 数组类型容易跟数组切片混淆，`[T;n]`描述了一个数组的类型，而`[T]`描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用[T;n]的形式去描述
`[u8; 3]`和`[u8; 4]`是不同的类型，数组的长度也是类型的一部分。

* 在实际开发中，使用最多的是数组切片`[T]`，我们往往通过引用的方式去使用`&[T]`，因为后者有固定的类型大小。